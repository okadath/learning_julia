<!DOCTYPE html>
<!-- saved from url=(0076)https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Integers and Floating-Point Numbers · The Julia Language</title><script async="" src="./Integers and Floating-Point Numbers · The Julia Language_files/analytics.js.descarga"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/index.html"><link href="./Integers and Floating-Point Numbers · The Julia Language_files/normalize.min.css" rel="stylesheet" type="text/css"><link href="./Integers and Floating-Point Numbers · The Julia Language_files/css" rel="stylesheet" type="text/css"><link href="./Integers and Floating-Point Numbers · The Julia Language_files/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="./Integers and Floating-Point Numbers · The Julia Language_files/default.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="./Integers and Floating-Point Numbers · The Julia Language_files/require.min.js.descarga" data-main="../../assets/documenter.js"></script><script src="./Integers and Floating-Point Numbers · The Julia Language_files/siteinfo.js.descarga"></script><script src="./Integers and Floating-Point Numbers · The Julia Language_files/versions.js.descarga"></script><link href="./Integers and Floating-Point Numbers · The Julia Language_files/documenter.css" rel="stylesheet" type="text/css"><link href="./Integers and Floating-Point Numbers · The Julia Language_files/julia-manual.css" rel="stylesheet" type="text/css"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="./Integers and Floating-Point Numbers · The Julia Language_files/documenter.js.descarga"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="jquery" src="./Integers and Floating-Point Numbers · The Julia Language_files/jquery.min.js.descarga"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="highlight" src="./Integers and Floating-Point Numbers · The Julia Language_files/highlight.min.js.descarga"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="headroom" src="./Integers and Floating-Point Numbers · The Julia Language_files/headroom.min.js.descarga"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="mathjax" src="./Integers and Floating-Point Numbers · The Julia Language_files/MathJax.js.descarga"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="highlight-julia" src="./Integers and Floating-Point Numbers · The Julia Language_files/julia.min.js.descarga"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="highlight-julia-repl" src="./Integers and Floating-Point Numbers · The Julia Language_files/julia-repl.min.js.descarga"></script><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head><body><div id="MathJax_Message" style="display: none;"></div><nav class="toc"><a href="https://docs.julialang.org/en/v1/index.html"><img class="logo" src="./Integers and Floating-Point Numbers · The Julia Language_files/logo.png" alt="The Julia Language logo"></a><h1>The Julia Language</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: visible;"><option value="#" selected="selected">v1.0.1</option><option value="../../../v1.0">v1.0</option><option value="../../../v0.7">v0.7</option><option value="../../../v0.6">v0.6</option><option value="../../../v0.5">v0.5</option><option value="../../../v0.4">v0.4</option><option value="../../../v0.3">v0.3</option><option value="../../../v1.1-dev">v1.1-dev</option></select><form class="search" id="search-form" action="https://docs.julialang.org/en/v1/search/"><input id="search-query" name="q" type="text" placeholder="Search docs"></form><ul><li><a class="toctext" href="https://docs.julialang.org/en/v1/">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/variables/">Variables</a></li><li class="current"><a class="toctext" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul class="internal"><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Integers-1">Integers</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Floating-Point-Numbers-1">Floating-Point Numbers</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Arbitrary-Precision-Arithmetic-1">Arbitrary Precision Arithmetic</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#man-numeric-literal-coefficients-1">Numeric Literal Coefficients</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Literal-zero-and-one-1">Literal zero and one</a></li></ul></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/strings/">Strings</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/functions/">Functions</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/types/">Types</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/methods/">Methods</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/constructors/">Constructors</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/modules/">Modules</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/documentation/">Documentation</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/missing/">Missing Values</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/code-loading/">Code Loading</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/profile/">Profiling</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/base/">Essentials</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/math/">Mathematics</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/numbers/">Numbers</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/strings/">Strings</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/arrays/">Arrays</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/parallel/">Tasks</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/constants/">Constants</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/file/">Filesystem</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/io-network/">I/O and Network</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/punctuation/">Punctuation</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/c/">C Interface</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/libc/">C Standard Library</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Base64/">Base64</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Dates/">Dates</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Logging/">Logging</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Printf/">Printf</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/SHA/">SHA</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia's Internals</span><ul><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/types/">More about types</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/require/">Module loading</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia's C code</span><ul><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="https://docs.julialang.org/en/v1/devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr><div id="topbar"><span>Integers and Floating-Point Numbers</span><a class="fa fa-bars" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#"></a></div></header><h1><a class="nav-anchor" id="Integers-and-Floating-Point-Numbers-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Integers-and-Floating-Point-Numbers-1">Integers and Floating-Point Numbers</a></h1><p>Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric literals. For example, <code>1</code> is an integer literal, while <code>1.0</code> is a floating-point literal; their binary in-memory representations as objects are numeric primitives.</p><p>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for <a href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Arbitrary-Precision-Arithmetic-1">Arbitrary Precision Arithmetic</a>, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</p><p>The following are Julia's primitive numeric types:</p><ul><li><strong>Integer types:</strong></li></ul><table><tbody><tr><th>Type</th><th>Signed?</th><th>Number of bits</th><th>Smallest value</th><th>Largest value</th></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Int8"><code>Int8</code></a></td><td>✓</td><td>8</td><td>-2^7</td><td>2^7 - 1</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.UInt8"><code>UInt8</code></a></td><td></td><td>8</td><td>0</td><td>2^8 - 1</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Int16"><code>Int16</code></a></td><td>✓</td><td>16</td><td>-2^15</td><td>2^15 - 1</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.UInt16"><code>UInt16</code></a></td><td></td><td>16</td><td>0</td><td>2^16 - 1</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Int32"><code>Int32</code></a></td><td>✓</td><td>32</td><td>-2^31</td><td>2^31 - 1</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.UInt32"><code>UInt32</code></a></td><td></td><td>32</td><td>0</td><td>2^32 - 1</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Int64"><code>Int64</code></a></td><td>✓</td><td>64</td><td>-2^63</td><td>2^63 - 1</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.UInt64"><code>UInt64</code></a></td><td></td><td>64</td><td>0</td><td>2^64 - 1</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Int128"><code>Int128</code></a></td><td>✓</td><td>128</td><td>-2^127</td><td>2^127 - 1</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.UInt128"><code>UInt128</code></a></td><td></td><td>128</td><td>0</td><td>2^128 - 1</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Bool"><code>Bool</code></a></td><td>N/A</td><td>8</td><td><code>false</code> (0)</td><td><code>true</code> (1)</td></tr></tbody></table><ul><li><strong>Floating-point types:</strong></li></ul><table><tbody><tr><th>Type</th><th>Precision</th><th>Number of bits</th></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Float16"><code>Float16</code></a></td><td><a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">half</a></td><td>16</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Float32"><code>Float32</code></a></td><td><a href="https://en.wikipedia.org/wiki/Single_precision_floating-point_format">single</a></td><td>32</td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Float64"><code>Float64</code></a></td><td><a href="https://en.wikipedia.org/wiki/Double_precision_floating-point_format">double</a></td><td>64</td></tr></tbody></table><p>Additionally, full support for <a href="https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/#Complex-and-Rational-Numbers-1">Complex and Rational Numbers</a> is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible <a href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/#conversion-and-promotion-1">type promotion system</a>.</p><h2><a class="nav-anchor" id="Integers-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Integers-1">Integers</a></h2><p>Literal integers are represented in the standard manner:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1</span>
</span>1

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1234</span>
</span>1234</code></pre><p>The default type for an integer literal depends on whether the target system has a 32-bit architecture or a 64-bit architecture:</p><pre><code class="language-julia-repl hljs"># 32-bit system:
<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(<span class="hljs-number">1</span>)
</span>Int32

# 64-bit system:
<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(<span class="hljs-number">1</span>)
</span>Int64</code></pre><p>The Julia internal variable <a href="https://docs.julialang.org/en/v1/base/constants/#Base.Sys.WORD_SIZE"><code>Sys.WORD_SIZE</code></a> indicates whether the target system is 32-bit or 64-bit:</p><pre><code class="language-julia-repl hljs"># 32-bit system:
<span class="hljs-meta">julia&gt;</span><span class="julia"> Sys.WORD_SIZE
</span>32

# 64-bit system:
<span class="hljs-meta">julia&gt;</span><span class="julia"> Sys.WORD_SIZE
</span>64</code></pre><p>Julia also defines the types <code>Int</code> and <code>UInt</code>, which are aliases for the system's signed and unsigned native integer types respectively:</p><pre><code class="language-julia-repl hljs"># 32-bit system:
<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">Int</span>
</span>Int32
<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">UInt</span>
</span>UInt32

# 64-bit system:
<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">Int</span>
</span>Int64
<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">UInt</span>
</span>UInt64</code></pre><p>Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always create 64-bit integers, regardless of the system type:</p><pre><code class="language-julia-repl hljs"># 32-bit or 64-bit system:
<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(<span class="hljs-number">3000000000</span>)
</span>Int64</code></pre><p>Unsigned integers are input and output using the <code>0x</code> prefix and hexadecimal (base 16) digits <code>0-9a-f</code> (the capitalized digits <code>A-F</code> also work for input). The size of the unsigned value is determined by the number of hex digits used:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x1</span>
</span>0x01

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)
</span>UInt8

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x123</span>
</span>0x0123

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)
</span>UInt16

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x1234567</span>
</span>0x01234567

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)
</span>UInt32

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x123456789abcdef</span>
</span>0x0123456789abcdef

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)
</span>UInt64

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x11112222333344445555666677778888</span>
</span>0x11112222333344445555666677778888

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)
</span>UInt128</code></pre><p>This behavior is based on the observation that when one uses unsigned hex literals for integer values, one typically is using them to represent a fixed numeric byte sequence, rather than just an integer value.</p><p>Recall that the variable <a href="https://docs.julialang.org/en/v1/base/base/#ans"><code>ans</code></a> is set to the value of the last expression evaluated in an interactive session. This does not occur when Julia code is run in other ways.</p><p>Binary and octal literals are also supported:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0b10</span>
</span>0x02

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)
</span>UInt8

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0o010</span>
</span>0x08

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)
</span>UInt8

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x00000000000000001111222233334444</span>
</span>0x00000000000000001111222233334444

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)
</span>UInt128</code></pre><p>As for hexadecimal literals, binary and octal literals produce unsigned integer types. The size of the binary data item is the minimal needed size, if the leading digit of the literal is not <code>0</code>. In the case of leading zeros, the size is determined by the minimal needed size for a literal, which has the same length but leading digit <code>1</code>. That allows the user to control the size. Values which cannot be stored in <code>UInt128</code> cannot be written as such literals.</p><p>Binary, octal, and hexadecimal literals may be signed by a <code>-</code> immediately preceding the unsigned literal. They produce an unsigned integer of the same size as the unsigned literal would do, with the two's complement of the value:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> -<span class="hljs-number">0x2</span>
</span>0xfe

<span class="hljs-meta">julia&gt;</span><span class="julia"> -<span class="hljs-number">0x0002</span>
</span>0xfffe</code></pre><p>The minimum and maximum representable values of primitive numeric types such as integers are given by the <a href="https://docs.julialang.org/en/v1/base/base/#Base.typemin"><code>typemin</code></a> and <a href="https://docs.julialang.org/en/v1/base/base/#Base.typemax"><code>typemax</code></a> functions:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> (typemin(<span class="hljs-built_in">Int32</span>), typemax(<span class="hljs-built_in">Int32</span>))
</span>(-2147483648, 2147483647)

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-keyword">for</span> T <span class="hljs-keyword">in</span> [<span class="hljs-built_in">Int8</span>,<span class="hljs-built_in">Int16</span>,<span class="hljs-built_in">Int32</span>,<span class="hljs-built_in">Int64</span>,<span class="hljs-built_in">Int128</span>,<span class="hljs-built_in">UInt8</span>,<span class="hljs-built_in">UInt16</span>,<span class="hljs-built_in">UInt32</span>,<span class="hljs-built_in">UInt64</span>,<span class="hljs-built_in">UInt128</span>]
           println(<span class="hljs-string">"<span class="hljs-subst">$(lpad(T,<span class="hljs-number">7</span>)</span>): [<span class="hljs-subst">$(typemin(T)</span>),<span class="hljs-subst">$(typemax(T)</span>)]"</span>)
       <span class="hljs-keyword">end</span>
</span>   Int8: [-128,127]
  Int16: [-32768,32767]
  Int32: [-2147483648,2147483647]
  Int64: [-9223372036854775808,9223372036854775807]
 Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
  UInt8: [0,255]
 UInt16: [0,65535]
 UInt32: [0,4294967295]
 UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]</code></pre><p>The values returned by <a href="https://docs.julialang.org/en/v1/base/base/#Base.typemin"><code>typemin</code></a> and <a href="https://docs.julialang.org/en/v1/base/base/#Base.typemax"><code>typemax</code></a> are always of the given argument type. (The above expression uses several features that have yet to be introduced, including <a href="https://docs.julialang.org/en/v1/manual/control-flow/#man-loops-1">for loops</a>, <a href="https://docs.julialang.org/en/v1/manual/strings/#man-strings-1">Strings</a>, and <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Interpolation-1">Interpolation</a>, but should be easy enough to understand for users with some existing programming experience.)</p><h3><a class="nav-anchor" id="Overflow-behavior-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Overflow-behavior-1">Overflow behavior</a></h3><p>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> x = typemax(<span class="hljs-built_in">Int64</span>)
</span>9223372036854775807

<span class="hljs-meta">julia&gt;</span><span class="julia"> x + <span class="hljs-number">1</span>
</span>-9223372036854775808

<span class="hljs-meta">julia&gt;</span><span class="julia"> x + <span class="hljs-number">1</span> == typemin(<span class="hljs-built_in">Int64</span>)
</span>true</code></pre><p>Thus, arithmetic with Julia integers is actually a form of <a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modular arithmetic</a>. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.GMP.BigInt"><code>BigInt</code></a> type in <a href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Arbitrary-Precision-Arithmetic-1">Arbitrary Precision Arithmetic</a> is recommended instead.</p><h3><a class="nav-anchor" id="Division-errors-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Division-errors-1">Division errors</a></h3><p>Integer division (the <code>div</code> function) has two exceptional cases: dividing by zero, and dividing the lowest negative number (<a href="https://docs.julialang.org/en/v1/base/base/#Base.typemin"><code>typemin</code></a>) by -1. Both of these cases throw a <a href="https://docs.julialang.org/en/v1/base/base/#Core.DivideError"><code>DivideError</code></a>. The remainder and modulus functions (<code>rem</code> and <code>mod</code>) throw a <a href="https://docs.julialang.org/en/v1/base/base/#Core.DivideError"><code>DivideError</code></a> when their second argument is zero.</p><h2><a class="nav-anchor" id="Floating-Point-Numbers-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Floating-Point-Numbers-1">Floating-Point Numbers</a></h2><p>Literal floating-point numbers are represented in the standard formats, using <a href="https://en.wikipedia.org/wiki/Scientific_notation#E-notation">E-notation</a> when necessary:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1.0</span>
</span>1.0

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1.</span>
</span>1.0

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0.5</span>
</span>0.5

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">.5</span>
</span>0.5

<span class="hljs-meta">julia&gt;</span><span class="julia"> -<span class="hljs-number">1.23</span>
</span>-1.23

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1e10</span>
</span>1.0e10

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">2.5e-4</span>
</span>0.00025</code></pre><p>The above results are all <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Float64"><code>Float64</code></a> values. Literal <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Float32"><code>Float32</code></a> values can be entered by writing an <code>f</code> in place of <code>e</code>:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0.5f0</span>
</span>0.5f0

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)
</span>Float32

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">2.5f-4</span>
</span>0.00025f0</code></pre><p>Values can be converted to <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Float32"><code>Float32</code></a> easily:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">Float32</span>(-<span class="hljs-number">1.5</span>)
</span>-1.5f0

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)
</span>Float32</code></pre><p>Hexadecimal floating-point literals are also valid, but only as <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Float64"><code>Float64</code></a> values, with <code>p</code> preceding the base-2 exponent:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x1p0</span>
</span>1.0

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x1.8p3</span>
</span>12.0

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0x.4p-1</span>
</span>0.125

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(ans)
</span>Float64</code></pre><p>Half-precision floating-point numbers are also supported (<a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Float16"><code>Float16</code></a>), but they are implemented in software and use <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Float32"><code>Float32</code></a> for calculations.</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> sizeof(<span class="hljs-built_in">Float16</span>(<span class="hljs-number">4.</span>))
</span>2

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">2</span>*<span class="hljs-built_in">Float16</span>(<span class="hljs-number">4.</span>)
</span>Float16(8.0)</code></pre><p>The underscore <code>_</code> can be used as digit separator:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">10_000</span>, <span class="hljs-number">0.000_000_005</span>, <span class="hljs-number">0xdead_beef</span>, <span class="hljs-number">0b1011_0010</span>
</span>(10000, 5.0e-9, 0xdeadbeef, 0xb2)</code></pre><h3><a class="nav-anchor" id="Floating-point-zero-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Floating-point-zero-1">Floating-point zero</a></h3><p>Floating-point numbers have <a href="https://en.wikipedia.org/wiki/Signed_zero">two zeros</a>, positive zero and negative zero. They are equal to each other but have different binary representations, as can be seen using the <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.bitstring"><code>bitstring</code></a> function:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0.0</span> == -<span class="hljs-number">0.0</span>
</span>true

<span class="hljs-meta">julia&gt;</span><span class="julia"> bitstring(<span class="hljs-number">0.0</span>)
</span>"0000000000000000000000000000000000000000000000000000000000000000"

<span class="hljs-meta">julia&gt;</span><span class="julia"> bitstring(-<span class="hljs-number">0.0</span>)
</span>"1000000000000000000000000000000000000000000000000000000000000000"</code></pre><h3><a class="nav-anchor" id="Special-floating-point-values-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Special-floating-point-values-1">Special floating-point values</a></h3><p>There are three specified standard floating-point values that do not correspond to any point on the real number line:</p><table><tbody><tr><th><code>Float16</code></th><th><code>Float32</code></th><th><code>Float64</code></th><th>Name</th><th>Description</th></tr><tr><td><code>Inf16</code></td><td><code>Inf32</code></td><td><code>Inf</code></td><td>positive infinity</td><td>a value greater than all finite floating-point values</td></tr><tr><td><code>-Inf16</code></td><td><code>-Inf32</code></td><td><code>-Inf</code></td><td>negative infinity</td><td>a value less than all finite floating-point values</td></tr><tr><td><code>NaN16</code></td><td><code>NaN32</code></td><td><code>NaN</code></td><td>not a number</td><td>a value not <code>==</code> to any floating-point value (including itself)</td></tr></tbody></table><p>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#Numeric-Comparisons-1">Numeric Comparisons</a>. By the <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 standard</a>, these floating-point values are the results of certain arithmetic operations:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1</span>/<span class="hljs-literal">Inf</span>
</span>0.0

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>
</span>Inf

<span class="hljs-meta">julia&gt;</span><span class="julia"> -<span class="hljs-number">5</span>/<span class="hljs-number">0</span>
</span>-Inf

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0.000001</span>/<span class="hljs-number">0</span>
</span>Inf

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0</span>/<span class="hljs-number">0</span>
</span>NaN

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">500</span> + <span class="hljs-literal">Inf</span>
</span>Inf

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">500</span> - <span class="hljs-literal">Inf</span>
</span>-Inf

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">Inf</span> + <span class="hljs-literal">Inf</span>
</span>Inf

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">Inf</span> - <span class="hljs-literal">Inf</span>
</span>NaN

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">Inf</span> * <span class="hljs-literal">Inf</span>
</span>Inf

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-literal">Inf</span> / <span class="hljs-literal">Inf</span>
</span>NaN

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">0</span> * <span class="hljs-literal">Inf</span>
</span>NaN</code></pre><p>The <a href="https://docs.julialang.org/en/v1/base/base/#Base.typemin"><code>typemin</code></a> and <a href="https://docs.julialang.org/en/v1/base/base/#Base.typemax"><code>typemax</code></a> functions also apply to floating-point types:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> (typemin(<span class="hljs-built_in">Float16</span>),typemax(<span class="hljs-built_in">Float16</span>))
</span>(-Inf16, Inf16)

<span class="hljs-meta">julia&gt;</span><span class="julia"> (typemin(<span class="hljs-built_in">Float32</span>),typemax(<span class="hljs-built_in">Float32</span>))
</span>(-Inf32, Inf32)

<span class="hljs-meta">julia&gt;</span><span class="julia"> (typemin(<span class="hljs-built_in">Float64</span>),typemax(<span class="hljs-built_in">Float64</span>))
</span>(-Inf, Inf)</code></pre><h3><a class="nav-anchor" id="Machine-epsilon-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Machine-epsilon-1">Machine epsilon</a></h3><p>Most real numbers cannot be represented exactly with floating-point numbers, and so for many purposes it is important to know the distance between two adjacent representable floating-point numbers, which is often known as <a href="https://en.wikipedia.org/wiki/Machine_epsilon">machine epsilon</a>.</p><p>Julia provides <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Base.eps"><code>eps</code></a>, which gives the distance between <code>1.0</code> and the next larger representable floating-point value:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-built_in">Float32</span>)
</span>1.1920929f-7

<span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-built_in">Float64</span>)
</span>2.220446049250313e-16

<span class="hljs-meta">julia&gt;</span><span class="julia"> eps() <span class="hljs-comment"># same as eps(Float64)</span>
</span>2.220446049250313e-16</code></pre><p>These values are <code>2.0^-23</code> and <code>2.0^-52</code> as <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Float32"><code>Float32</code></a> and <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Float64"><code>Float64</code></a> values, respectively. The <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Base.eps"><code>eps</code></a> function can also take a floating-point value as an argument, and gives the absolute difference between that value and the next representable floating point value. That is, <code>eps(x)</code> yields a value of the same type as <code>x</code> such that <code>x + eps(x)</code> is the next representable floating-point value larger than <code>x</code>:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-number">1.0</span>)
</span>2.220446049250313e-16

<span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-number">1000.</span>)
</span>1.1368683772161603e-13

<span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-number">1e-27</span>)
</span>1.793662034335766e-43

<span class="hljs-meta">julia&gt;</span><span class="julia"> eps(<span class="hljs-number">0.0</span>)
</span>5.0e-324</code></pre><p>The distance between two adjacent representable floating-point numbers is not constant, but is smaller for smaller values and larger for larger values. In other words, the representable floating-point numbers are densest in the real number line near zero, and grow sparser exponentially as one moves farther away from zero. By definition, <code>eps(1.0)</code> is the same as <code>eps(Float64)</code> since <code>1.0</code> is a 64-bit floating-point value.</p><p>Julia also provides the <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.nextfloat"><code>nextfloat</code></a> and <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.prevfloat"><code>prevfloat</code></a> functions which return the next largest or smallest representable floating-point number to the argument respectively:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> x = <span class="hljs-number">1.25f0</span>
</span>1.25f0

<span class="hljs-meta">julia&gt;</span><span class="julia"> nextfloat(x)
</span>1.2500001f0

<span class="hljs-meta">julia&gt;</span><span class="julia"> prevfloat(x)
</span>1.2499999f0

<span class="hljs-meta">julia&gt;</span><span class="julia"> bitstring(prevfloat(x))
</span>"00111111100111111111111111111111"

<span class="hljs-meta">julia&gt;</span><span class="julia"> bitstring(x)
</span>"00111111101000000000000000000000"

<span class="hljs-meta">julia&gt;</span><span class="julia"> bitstring(nextfloat(x))
</span>"00111111101000000000000000000001"</code></pre><p>This example highlights the general principle that the adjacent representable floating-point numbers also have adjacent binary integer representations.</p><h3><a class="nav-anchor" id="Rounding-modes-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Rounding-modes-1">Rounding modes</a></h3><p>If a number doesn't have an exact floating-point representation, it must be rounded to an appropriate representable value. However, the manner in which this rounding is done can be changed if required according to the rounding modes presented in the <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 standard</a>.</p><p>The default mode used is always <a href="https://docs.julialang.org/en/v1/base/math/#Base.Rounding.RoundNearest"><code>RoundNearest</code></a>, which rounds to the nearest representable value, with ties rounded towards the nearest value with an even least significant bit.</p><h3><a class="nav-anchor" id="Background-and-References-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Background-and-References-1">Background and References</a></h3><p>Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar with the low-level implementation details. However, these subtleties are described in detail in most books on scientific computation, and also in the following references:</p><ul><li>The definitive guide to floating point arithmetic is the <a href="http://standards.ieee.org/findstds/standard/754-2008.html">IEEE 754-2008 Standard</a>; however, it is not available for free online.</li><li>For a brief but lucid presentation of how floating-point numbers are represented, see John D. Cook's <a href="https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/">article</a> on the subject as well as his <a href="https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/">introduction</a> to some of the issues arising from how this representation differs in behavior from the idealized abstraction of real numbers.</li><li>Also recommended is Bruce Dawson's <a href="https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/">series of blog posts on floating-point numbers</a>.</li><li>For an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy encountered when computing with them, see David Goldberg's paper <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;rep=rep1&amp;type=pdf">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>.</li><li>For even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of many other topics in numerical computing, see the <a href="https://people.eecs.berkeley.edu/~wkahan/">collected writings</a> of <a href="https://en.wikipedia.org/wiki/William_Kahan">William Kahan</a>, commonly known as the "Father of Floating-Point". Of particular interest may be <a href="https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html">An Interview with the Old Man of Floating-Point</a>.</li></ul><h2><a class="nav-anchor" id="Arbitrary-Precision-Arithmetic-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Arbitrary-Precision-Arithmetic-1">Arbitrary Precision Arithmetic</a></h2><p>To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps the <a href="https://gmplib.org/">GNU Multiple Precision Arithmetic Library (GMP)</a> and the <a href="http://www.mpfr.org/">GNU MPFR Library</a>, respectively. The <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.GMP.BigInt"><code>BigInt</code></a> and <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.MPFR.BigFloat"><code>BigFloat</code></a> types are available in Julia for arbitrary precision integer and floating point numbers respectively.</p><p>Constructors exist to create these types from primitive numerical types, and <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.parse"><code>parse</code></a> can be used to construct them from <code>AbstractString</code>s.  Once created, they participate in arithmetic with all other numeric types thanks to Julia's <a href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/#conversion-and-promotion-1">type promotion and conversion mechanism</a>:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">BigInt</span>(typemax(<span class="hljs-built_in">Int64</span>)) + <span class="hljs-number">1</span>
</span>9223372036854775808

<span class="hljs-meta">julia&gt;</span><span class="julia"> parse(<span class="hljs-built_in">BigInt</span>, <span class="hljs-string">"123456789012345678901234567890"</span>) + <span class="hljs-number">1</span>
</span>123456789012345678901234567891

<span class="hljs-meta">julia&gt;</span><span class="julia"> parse(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-string">"1.23456789012345678901"</span>)
</span>1.234567890123456789010000000000000000000000000000000000000000000000000000000004

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-built_in">BigFloat</span>(<span class="hljs-number">2.0</span>^<span class="hljs-number">66</span>) / <span class="hljs-number">3</span>
</span>2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19

<span class="hljs-meta">julia&gt;</span><span class="julia"> factorial(<span class="hljs-built_in">BigInt</span>(<span class="hljs-number">40</span>))
</span>815915283247897734345611269596115894272000000000</code></pre><p>However, type promotion between the primitive types above and <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.GMP.BigInt"><code>BigInt</code></a>/<a href="https://docs.julialang.org/en/v1/base/numbers/#Base.MPFR.BigFloat"><code>BigFloat</code></a> is not automatic and must be explicitly stated.</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> x = typemin(<span class="hljs-built_in">Int64</span>)
</span>-9223372036854775808

<span class="hljs-meta">julia&gt;</span><span class="julia"> x = x - <span class="hljs-number">1</span>
</span>9223372036854775807

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(x)
</span>Int64

<span class="hljs-meta">julia&gt;</span><span class="julia"> y = <span class="hljs-built_in">BigInt</span>(typemin(<span class="hljs-built_in">Int64</span>))
</span>-9223372036854775808

<span class="hljs-meta">julia&gt;</span><span class="julia"> y = y - <span class="hljs-number">1</span>
</span>-9223372036854775809

<span class="hljs-meta">julia&gt;</span><span class="julia"> typeof(y)
</span>BigInt</code></pre><p>The default precision (in number of bits of the significand) and rounding mode of <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.MPFR.BigFloat"><code>BigFloat</code></a> operations can be changed globally by calling <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.MPFR.setprecision"><code>setprecision</code></a> and <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.Rounding.setrounding-Tuple{Type,Any}"><code>setrounding</code></a>, and all further calculations will take these changes in account.  Alternatively, the precision or the rounding can be changed only within the execution of a particular block of code by using the same functions with a <code>do</code> block:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> setrounding(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-literal">RoundUp</span>) <span class="hljs-keyword">do</span>
           <span class="hljs-built_in">BigFloat</span>(<span class="hljs-number">1</span>) + parse(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-string">"0.1"</span>)
       <span class="hljs-keyword">end</span>
</span>1.100000000000000000000000000000000000000000000000000000000000000000000000000003

<span class="hljs-meta">julia&gt;</span><span class="julia"> setrounding(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-literal">RoundDown</span>) <span class="hljs-keyword">do</span>
           <span class="hljs-built_in">BigFloat</span>(<span class="hljs-number">1</span>) + parse(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-string">"0.1"</span>)
       <span class="hljs-keyword">end</span>
</span>1.099999999999999999999999999999999999999999999999999999999999999999999999999986

<span class="hljs-meta">julia&gt;</span><span class="julia"> setprecision(<span class="hljs-number">40</span>) <span class="hljs-keyword">do</span>
           <span class="hljs-built_in">BigFloat</span>(<span class="hljs-number">1</span>) + parse(<span class="hljs-built_in">BigFloat</span>, <span class="hljs-string">"0.1"</span>)
       <span class="hljs-keyword">end</span>
</span>1.1000000000004</code></pre><h2><a class="nav-anchor" id="man-numeric-literal-coefficients-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#man-numeric-literal-coefficients-1">Numeric Literal Coefficients</a></h2><p>To make common numeric formulae and expressions clearer, Julia allows variables to be immediately preceded by a numeric literal, implying multiplication. This makes writing polynomial expressions much cleaner:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> x = <span class="hljs-number">3</span>
</span>3

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">2</span>x^<span class="hljs-number">2</span> - <span class="hljs-number">3</span>x + <span class="hljs-number">1</span>
</span>10

<span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">1.5</span>x^<span class="hljs-number">2</span> - <span class="hljs-number">.5</span>x + <span class="hljs-number">1</span>
</span>13.0</code></pre><p>It also makes writing exponential functions more elegant:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">2</span>^<span class="hljs-number">2</span>x
</span>64</code></pre><p>The precedence of numeric literal coefficients is slightly lower than that of unary operators such as negation. So <code>-2x</code> is parsed as <code>(-2) * x</code> and <code>√2x</code> is parsed as <code>(√2) * x</code>. However, numeric literal coefficients parse similarly to unary operators when combined with exponentiation. For example <code>2^3x</code> is parsed as <code>2^(3x)</code>, and <code>2x^3</code> is parsed as <code>2*(x^3)</code>.</p><p>Numeric literals also work as coefficients to parenthesized expressions:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> <span class="hljs-number">2</span>(x-<span class="hljs-number">1</span>)^<span class="hljs-number">2</span> - <span class="hljs-number">3</span>(x-<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>
</span>3</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The precedence of numeric literal coefficients used for implicit multiplication is higher than other binary operators such as multiplication (<code>*</code>), and division (<code>/</code>, <code>\</code>, and <code>//</code>).  This means, for example, that <code>1 / 2im</code> equals <code>-0.5im</code> and <code>6 // 2(2 + 1)</code> equals <code>1 // 1</code>.</p></div></div><p>Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> (x-<span class="hljs-number">1</span>)x
</span>6</code></pre><p>Neither juxtaposition of two parenthesized expressions, nor placing a variable before a parenthesized expression, however, can be used to imply multiplication:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> (x-<span class="hljs-number">1</span>)(x+<span class="hljs-number">1</span>)
</span>ERROR: MethodError: objects of type Int64 are not callable

<span class="hljs-meta">julia&gt;</span><span class="julia"> x(x+<span class="hljs-number">1</span>)
</span>ERROR: MethodError: objects of type Int64 are not callable</code></pre><p>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see <a href="https://docs.julialang.org/en/v1/manual/faq/#Functions-1">Functions</a> for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</p><p>The above syntactic enhancements significantly reduce the visual noise incurred when writing common mathematical formulae. Note that no whitespace may come between a numeric literal coefficient and the identifier or parenthesized expression which it multiplies.</p><h3><a class="nav-anchor" id="Syntax-Conflicts-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Syntax-Conflicts-1">Syntax Conflicts</a></h3><p>Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation for floating-point literals. Here are some situations where syntactic conflicts arise:</p><ul><li>The hexadecimal integer literal expression <code>0xff</code> could be interpreted as the numeric literal <code>0</code> multiplied by the variable <code>xff</code>.</li><li>The floating-point literal expression <code>1e10</code> could be interpreted as the numeric literal <code>1</code> multiplied by the variable <code>e10</code>, and similarly with the equivalent <code>E</code> form.</li><li>The 32-bit floating-point literal expression <code>1.5f22</code> could be interpreted as the numeric literal <code>1.5</code> multiplied by the variable <code>f22</code>.</li></ul><p>In all cases the ambiguity is resolved in favor of interpretation as numeric literals:</p><ul><li>Expressions starting with <code>0x</code> are always hexadecimal literals.</li><li>Expressions starting with a numeric literal followed by <code>e</code> or <code>E</code> are always floating-point literals.</li><li>Expressions starting with a numeric literal followed by <code>f</code> are always 32-bit floating-point literals.</li></ul><p>Unlike <code>E</code>, which is equivalent to <code>e</code> in numeric literals for historical reasons, <code>F</code> is just another letter and does not behave like <code>f</code> in numeric literals. Hence, expressions starting with a numeric literal followed by <code>F</code> are interpreted as the numerical literal multiplied by a variable, which means that, for example, <code>1.5F22</code> is equal to <code>1.5 * F22</code>.</p><h2><a class="nav-anchor" id="Literal-zero-and-one-1" href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Literal-zero-and-one-1">Literal zero and one</a></h2><p>Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable.</p><table><tbody><tr><th>Function</th><th>Description</th></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Base.zero"><code>zero(x)</code></a></td><td>Literal zero of type <code>x</code> or type of variable <code>x</code></td></tr><tr><td><a href="https://docs.julialang.org/en/v1/base/numbers/#Base.one"><code>one(x)</code></a></td><td>Literal one of type <code>x</code> or type of variable <code>x</code></td></tr></tbody></table><p>These functions are useful in <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#Numeric-Comparisons-1">Numeric Comparisons</a> to avoid overhead from unnecessary <a href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/#conversion-and-promotion-1">type conversion</a>.</p><p>Examples:</p><pre><code class="language-julia-repl hljs"><span class="hljs-meta">julia&gt;</span><span class="julia"> zero(<span class="hljs-built_in">Float32</span>)
</span>0.0f0

<span class="hljs-meta">julia&gt;</span><span class="julia"> zero(<span class="hljs-number">1.0</span>)
</span>0.0

<span class="hljs-meta">julia&gt;</span><span class="julia"> one(<span class="hljs-built_in">Int32</span>)
</span>1

<span class="hljs-meta">julia&gt;</span><span class="julia"> one(<span class="hljs-built_in">BigFloat</span>)
</span>1.0</code></pre><footer><hr><a class="previous" href="https://docs.julialang.org/en/v1/manual/variables/"><span class="direction">Previous</span><span class="title">Variables</span></a><a class="next" href="https://docs.julialang.org/en/v1/manual/mathematical-operations/"><span class="direction">Next</span><span class="title">Mathematical Operations and Elementary Functions</span></a></footer></article>
</body></html>